# /// script
# requires-python = ">=3.13"
# dependencies = [
#     "requests",
#     "python-jose[cryptography]",
# ]
# ///

import base64
import hashlib
import http.server
import json
import random
import secrets
import socketserver
import string
import time
import urllib.error
import urllib.parse
import urllib.request
from threading import Event, Thread
from typing import Any
from urllib.parse import urlencode

import requests
from jose import jwt
from jose.exceptions import ExpiredSignatureError, JWTError

# client_id = "your_client_id"
# Note: we do not use the client secret in this flow
METADATA_URL = "https://login.eveonline.com/.well-known/oauth-authorization-server"
METADATA_CACHE_TIME = 300  # 5 minutes
ACCEPTED_ISSUERS = ("logineveonline.com", "https://login.eveonline.com")
EXPECTED_AUDIENCE = "EVE Online"
CALLBACK_URL = "http://localhost:8080/callback"


# We don't want to fetch the jwks data on every request, so we cache it for a short period
jwks_metadata = None
jwks_metadata_ttl = 0


def generate_code_challenge() -> tuple[bytes, str]:
    """Generates a code challenge for PKCE.

    :returns tuple[str,str]: A tuple containing the code verifier and code challenge
    """
    code_verifier = base64.urlsafe_b64encode(secrets.token_bytes(32))
    sha256 = hashlib.sha256()
    sha256.update(code_verifier)
    code_challenge = base64.urlsafe_b64encode(sha256.digest()).decode().rstrip("=")
    return (code_verifier, code_challenge)


def request_token(
    client_id: str, authorization_code: str, code_verifier: str
) -> dict[str, Any]:
    """Takes an authorization code and code verifier and exchanges it for an access token and refresh token.

    :param str authorization_code: The authorization code received from the SSO
    :param str code_verifier: The code verifier used to generate the code challenge, as generated by `generate_code_challenge`
    :returns: A dictionary containing the access token and refresh token
    """
    headers = {
        "Content-Type": "application/x-www-form-urlencoded",
    }
    payload = {
        "grant_type": "authorization_code",
        "code": authorization_code,
        "client_id": client_id,
        "code_verifier": code_verifier,
    }
    response = requests.post(
        "https://login.eveonline.com/v2/oauth/token", headers=headers, data=payload
    )
    response.raise_for_status()

    return response.json()


def redirect_to_sso(
    client_id: str, scopes: list[str], redirect_uri: str, challenge: str
) -> tuple[str, str]:
    """Generates a URL to redirect the user to the SSO for authentication.

    :param list[str] scopes: A list of scopes that the application is requesting access to
    :param str redirect_uri: The URL where the user will be redirected back to after the authorization flow is complete
    :param str challenge: A challenge as generated by `generate_code_challenge`
    :returns: A tuple containing the URL and the state parameter that was used
    """
    state = "".join(random.choices(string.ascii_letters + string.digits, k=16))
    query_params = {
        "response_type": "code",
        "client_id": client_id,
        "redirect_uri": redirect_uri,
        "scope": " ".join(scopes),
        "state": state,
        "code_challenge": challenge,
        "code_challenge_method": "S256",
    }
    query_string = urlencode(query_params)
    return (f"https://login.eveonline.com/v2/oauth/authorize?{query_string}", state)


def fetch_jwks_metadata() -> dict[str, Any]:
    """Fetches the JWKS metadata from the SSO server.

    :returns: The JWKS metadata
    """
    global jwks_metadata, jwks_metadata_ttl
    if jwks_metadata is None or jwks_metadata_ttl < time.time():
        resp = requests.get(METADATA_URL)
        resp.raise_for_status()
        metadata = resp.json()

        jwks_uri = metadata["jwks_uri"]

        resp = requests.get(jwks_uri)
        resp.raise_for_status()

        jwks_metadata = resp.json()
        jwks_metadata_ttl = time.time() + METADATA_CACHE_TIME
    return jwks_metadata


def validate_jwt_token(token: str) -> dict[str, Any]:
    """Validates a JWT Token.

    :param str token: The JWT token to validate
    :returns: The content of the validated JWT access token
    :raises ExpiredSignatureError: If the token has expired
    :raises JWTError: If the token is invalid
    """
    metadata = fetch_jwks_metadata()
    keys = metadata["keys"]
    # Fetch the key algorithm and key idfentifier from the token header
    header = jwt.get_unverified_header(token)
    key = [
        item
        for item in keys
        if item["kid"] == header["kid"] and item["alg"] == header["alg"]
    ].pop()
    return jwt.decode(
        token,
        key=key,
        algorithms=header["alg"],
        issuer=ACCEPTED_ISSUERS,
        audience=EXPECTED_AUDIENCE,
    )


def is_token_valid(client_id: str, token: str) -> bool:
    """Simple check if the token is valid or not.

    :returns: True if the token is valid, False otherwise
    """
    try:
        claims = validate_jwt_token(token)
        # If our client_id is in the audience list, the token is valid, otherwise, we got a token for another client.
        return client_id in claims["aud"]
    except ExpiredSignatureError:
        # The token has expired
        return False
    except JWTError:
        # The token is invalid
        return False
    except Exception:
        # Something went wrong
        return False


class EVECallbackHandler(http.server.BaseHTTPRequestHandler):
    def __init__(self, request, client_address, server, result: dict[str, Any]):
        self.result = result
        super().__init__(request, client_address, server)

    def do_GET(self):
        # Parse the callback URL
        parsed_url = urllib.parse.urlparse(self.path)
        query_params = urllib.parse.parse_qs(parsed_url.query)

        if parsed_url.path == "/callback":
            # Check if we received an authorization code
            if "code" in query_params:
                self.result = query_params
                auth_code = query_params["code"][0]
                state = query_params.get("state", [""])[0]

                print(f"\nReceived authorization code: {auth_code}")
                print(f"State: {state}")

                # Exchange authorization code for access token
                try:
                    # token_data = self.exchange_code_for_token(auth_code)

                    # Send success response to browser
                    self.send_response(200)
                    self.send_header("Content-type", "text/html")
                    self.end_headers()

                    success_html = f"""
                    <html>
                    <head><title>EVE Online Authorization Successful</title></head>
                    <body>
                        <h1>Authorization Successful!</h1>
                        <p>You can close this window now.</p>
                    </body>
                    </html>
                    """
                    self.wfile.write(success_html.encode())

                    # # Store the token data (in a real app, you'd save this securely)
                    # print("Token data received:")
                    # print(json.dumps(token_data, indent=2))

                except Exception as e:
                    print(f"Error exchanging code for token: {e}")
                    self.send_error(500, f"Token exchange failed: {e}")

            elif "error" in query_params:
                error = query_params["error"][0]
                error_description = query_params.get("error_description", [""])[0]

                print(f"Authorization error: {error}")
                print(f"Error description: {error_description}")

                self.send_response(400)
                self.send_header("Content-type", "text/html")
                self.end_headers()

                error_html = f"""
                <html>
                <head><title>EVE Online Authorization Error</title></head>
                <body>
                    <h1>Authorization Failed</h1>
                    <p>Error: {error}</p>
                    <p>Description: {error_description}</p>
                </body>
                </html>
                """
                self.wfile.write(error_html.encode())
        else:
            # Default response for other paths
            self.send_response(404)
            self.end_headers()

    # def exchange_code_for_token(self, auth_code):
    #     """Exchange authorization code for access token"""
    #     token_url = "https://login.eveonline.com/v2/oauth/token"

    #     # Prepare the request data
    #     data = {"grant_type": "authorization_code", "code": auth_code}

    #     # Encode the data
    #     post_data = urllib.parse.urlencode(data).encode()

    #     # Create basic auth header
    #     credentials = f"{self.client_id}:{self.client_secret}"
    #     encoded_credentials = base64.b64encode(credentials.encode()).decode()

    #     # Create the request
    #     req = urllib.request.Request(token_url, data=post_data)
    #     req.add_header("Authorization", f"Basic {encoded_credentials}")
    #     req.add_header("Content-Type", "application/x-www-form-urlencoded")
    #     req.add_header("Host", "login.eveonline.com")

    #     # Make the request
    #     try:
    #         with urllib.request.urlopen(req) as response:
    #             response_data = response.read().decode()
    #             return json.loads(response_data)
    #     except urllib.error.HTTPError as e:
    #         error_data = e.read().decode()
    #         raise Exception(f"HTTP {e.code}: {error_data}")

    # def log_message(self, format, *args):
    #     # Suppress default request logging, or customize as needed
    #     pass


class EVECallbackServer:
    def __init__(self, result: dict[str, Any], port=8080, timeout=300):
        # self.client_id = client_id
        # self.client_secret = client_secret
        self.port = port
        self.timeout = timeout  # Timeout in seconds (default: 5 minutes)
        self.httpd = None
        self.server_thread = None
        self.shutdown_event = Event()
        self.start_time = None
        self.result = result

    def start(self):
        """Start the callback server"""

        # Create a handler class with our credentials
        def handler_factory(request, client_address, server):
            return EVECallbackHandler(request, client_address, server, self.result)

        # Start the server
        self.httpd = socketserver.TCPServer(("", self.port), handler_factory)
        self.httpd = socketserver.TCPServer(("", self.port), handler_factory)
        self.httpd.allow_reuse_address = True
        self.httpd.timeout = 1.0  # Short timeout for socket operations

        # Record start time
        self.start_time = time.time()

        # Run server in a separate thread
        self.server_thread = Thread(target=self._run_server)
        self.server_thread.daemon = True
        self.server_thread.start()

        print(f"Callback server started on http://localhost:{self.port}")
        print(f"Callback URL: http://localhost:{self.port}/callback")
        print(f"Server will timeout after {self.timeout} seconds")

    def _run_server(self):
        """Run the server with timeout checking"""
        while not self.shutdown_event.is_set():
            # Check if timeout has been reached
            if time.time() - self.start_time > self.timeout:
                print(f"\nServer timeout reached ({self.timeout}s). Shutting down...")
                self.shutdown_event.set()
                break

            try:
                # Handle one request with a short timeout
                self.httpd.timeout = 1.0
                self.httpd.handle_request()
            except OSError:
                # Socket timeout or other OS error - continue checking
                continue

        self.httpd.server_close()

    def stop(self):
        """Stop the callback server"""
        self.shutdown_event.set()
        if self.httpd:
            self.httpd.shutdown()
            self.httpd.server_close()
        if self.server_thread and self.server_thread.is_alive():
            self.server_thread.join(timeout=2.0)
        print("Callback server stopped")

    def is_running(self):
        """Check if the server is still running"""
        return (
            self.server_thread
            and self.server_thread.is_alive()
            and not self.shutdown_event.is_set()
            and (time.time() - self.start_time) < self.timeout
        )

    def time_remaining(self):
        """Get remaining time before timeout"""
        if not self.start_time:
            return 0
        elapsed = time.time() - self.start_time
        return max(0, self.timeout - elapsed)


def main() -> None:
    TIMEOUT = 300  # 5 minutes timeout
    code_challenge, code_verifier = generate_code_challenge()
    # redirect_uri = "http://localhost:8000/callback"
    scopes = ["publicData", "esi-wallet.read_character_wallet.v1"]
    client_id = input("Enter your client ID: ")
    url, state = redirect_to_sso(client_id, scopes, CALLBACK_URL, code_challenge)
    print("Go to the following URL to authorize the application:")
    print(url)
    print()
    result: dict[str, Any] = {}
    server = EVECallbackServer(result, timeout=TIMEOUT)
    server.start()
    print("\nTo authorize your application:")
    print(f"Open this URL in your browser: {url}")
    print(f"\nServer will automatically stop after {TIMEOUT} seconds")
    print("Press Ctrl+C to stop the server early")

    try:
        # Keep the main thread alive and show countdown
        while server.is_running():
            remaining = server.time_remaining()
            if remaining > 0:
                print(f"\rTime remaining: {remaining:.0f}s", end="", flush=True)
                time.sleep(1)
            else:
                break
    except KeyboardInterrupt:
        print("\n\nReceived interrupt signal...")
    finally:
        print("\nShutting down server...")
        server.stop()

    print(f"result: {result!r}")
    authorization_code = input("Enter the authorization code: ")
    token_response = request_token(client_id, authorization_code, code_verifier)
    access_token = token_response["access_token"]
    refresh_token = token_response["refresh_token"]

    print("Access Token:", access_token)
    print("Refresh Token:", refresh_token)
    print("Is Access Token valid?", is_token_valid(client_id, access_token))


if __name__ == "__main__":
    main()
