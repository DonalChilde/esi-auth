"""An example script demonstrating OAuth2 Authorization Code Flow with PKCE for EVE Online SSO.

To use this script, you must first register an application at
https://developers.eveonline.com/ to obtain a client ID and configure the
redirect URI.

Running the script will open a browser window to authenticate with EVE SSO,
and then start a temporary HTTP server to receive the OAuth callback with the
authorization code. The script will then exchange the authorization code for an
access token and refresh token, validate the JWT access token, and demonstrate
refreshing the tokens.

Make sure to configure the callback settings in this script to match your
EVE SSO application redirect URI.

The easiest way to run this script is using uv:

    `uv run <path_to_script>/get_auth_code.py`

uv will manage creating a virtual environment and installing the required
dependencies.

Instructions for installing uv can be found at https://docs.astral.sh/uv/

"""

# /// script
# requires-python = ">=3.13"
# dependencies = [
#     "aiohttp",
#     "pyjwt[crypto]",
#     "rich",
# ]
# ///
import asyncio
import base64
import hashlib
import logging
import random
import secrets
import string
import webbrowser
from collections.abc import Sequence
from typing import Any, TypedDict
from urllib.parse import urlencode

import aiohttp
import jwt
from aiohttp import web
from jwt.jwks_client import PyJWKClient
from rich.console import Console

logger = logging.getLogger(__name__)

USER_AGENT = "Example auth script/1.0"


############################################################################
# These TypedDicts are used for type hinting the JSON responses from the SSO
# and token endpoints.
############################################################################
class JWK(TypedDict):
    kty: str
    use: str
    kid: str
    alg: str
    n: str
    e: str


class JWKS(TypedDict):
    keys: list[JWK]


class OauthMetadata(TypedDict):
    issuer: str
    authorization_endpoint: str
    token_endpoint: str
    jwks_uri: str
    response_types_supported: list[str]
    subject_types_supported: list[str]
    id_token_signing_alg_values_supported: list[str]
    scopes_supported: list[str]
    token_endpoint_auth_methods_supported: list[str]
    claims_supported: list[str]


class OauthToken(TypedDict):
    access_token: str
    token_type: str
    expires_in: int
    refresh_token: str


class AuthenticationError(Exception):
    """Exception raised during authentication process.

    This exception is raised when authentication fails or encounters
    an error during the OAuth flow or token operations.
    """

    def __init__(self, message: str, error_code: str | None = None):
        """Initialize the authentication error.

        Args:
            message: Human-readable error message.
            error_code: Optional error code for programmatic handling.
        """
        super().__init__(message)
        self.message = message
        self.error_code = error_code


############################################################################
# from authorization-code-pkce.py
############################################################################
def generate_code_challenge() -> tuple[bytes, str]:
    """Generates a code challenge for PKCE.

    :returns: A tuple containing the code verifier and code challenge
    """
    code_verifier = base64.urlsafe_b64encode(secrets.token_bytes(32))
    sha256 = hashlib.sha256()
    sha256.update(code_verifier)
    code_challenge = base64.urlsafe_b64encode(sha256.digest()).decode().rstrip("=")
    return (code_verifier, code_challenge)


async def request_token(
    client_id: str,
    authorization_code: str,
    code_verifier: str,
    client_session: aiohttp.ClientSession,
) -> OauthToken:
    """Takes an authorization code and code verifier and exchanges it for an access token and refresh token.

    :param str authorization_code: The authorization code received from the SSO
    :param str code_verifier: The code verifier used to generate the code challenge, as generated by `generate_code_challenge`
    :returns: A dictionary containing the access token and refresh token
    """
    if not client_session:
        raise ValueError("client_session must be initialized")
    # if client_session is None:
    #     client_session = aiohttp.ClientSession()
    headers = {
        "Content-Type": "application/x-www-form-urlencoded",
        "User-Agent": USER_AGENT,
    }
    payload: dict[str, str] = {
        "grant_type": "authorization_code",
        "code": authorization_code,
        "client_id": client_id,
        "code_verifier": code_verifier,
    }
    response = await client_session.post(
        "https://login.eveonline.com/v2/oauth/token", headers=headers, data=payload
    )
    response.raise_for_status()
    result = await response.json()

    return result


async def refresh_token(
    refresh_token: str,
    client_id: str,
    client_session: aiohttp.ClientSession,
) -> OauthToken:
    """Takes a refresh token and exchanges it for a new access token and refresh token.

    :param str refresh_token: The refresh token received from the SSO
    :param str client_id: The client ID of the application
    :returns: A dictionary containing the new access token and refresh token
    """
    if not client_session:
        raise ValueError("client_session must be initialized")
    # if client_session is None:
    #     client_session = aiohttp.ClientSession()
    headers = {
        "Content-Type": "application/x-www-form-urlencoded",
        "User-Agent": USER_AGENT,
    }
    payload: dict[str, str] = {
        "client_id": client_id,
        "grant_type": "refresh_token",
        "refresh_token": refresh_token,
    }
    response = await client_session.post(
        "https://login.eveonline.com/v2/oauth/token", headers=headers, data=payload
    )
    response.raise_for_status()
    result = await response.json()

    return result


def redirect_to_sso(
    client_id: str, scopes: Sequence[str], redirect_uri: str, challenge: str
) -> tuple[str, str]:
    """Generates a URL to redirect the user to the SSO for authentication.

    :param list[str] scopes: A list of scopes that the application is requesting access to
    :param str redirect_uri: The URL where the user will be redirected back to after the authorization flow is complete
    :param str challenge: A challenge as generated by `generate_code_challenge`
    :returns: A tuple containing the URL and the state parameter that was used
    """
    state = "".join(random.choices(string.ascii_letters + string.digits, k=16))
    query_params = {
        "response_type": "code",
        "client_id": client_id,
        "redirect_uri": redirect_uri,
        "scope": " ".join(scopes),
        "state": state,
        "code_challenge": challenge,
        "code_challenge_method": "S256",
    }
    query_string = urlencode(query_params)
    return (f"https://login.eveonline.com/v2/oauth/authorize?{query_string}", state)


#############################################################################
# end from authorization-code-pkce.py
#############################################################################

#############################################################################
# from validate-jwt-token.py
#############################################################################


async def fetch_oauth_metadata(
    client_session: aiohttp.ClientSession, oauth_metadata_url: str
) -> OauthMetadata:
    """Fetches the OAuth metadata from the SSO server."""
    header = {"User-Agent": USER_AGENT}
    logger.info(f"Fetching OAuth metadata from {oauth_metadata_url}")
    response = await client_session.get(oauth_metadata_url, headers=header)
    response.raise_for_status()
    result = await response.json()

    return result


async def fetch_jwks(
    client_session: aiohttp.ClientSession,
    oauth_metadata: OauthMetadata,
) -> JWKS:
    """Fetches the JWKS metadata from the SSO server.

    :returns: The JWKS metadata
    """
    header = {"User-Agent": USER_AGENT}
    url: str = oauth_metadata["jwks_uri"]
    logger.info(f"Fetching JWKS from {url}")
    response = await client_session.get(url, headers=header)
    response.raise_for_status()
    result = await response.json()

    return result


def validate_jwt_token(
    access_token: str,
    jkws_uri: str,
    signing_algos: list[str],
    audience: str,
    issuers: Sequence[str],
) -> dict[str, Any]:
    """Validates a JWT Token.

    :param str token: The JWT token to validate
    :returns: The content of the validated JWT access token
    :raises ExpiredSignatureError: If the token has expired
    :raises ExpiredSignatureError: If the token is invalid
    :raises Exception: If any other error occurs
    """
    # TODO include other validation info, like audience, issuer, etc.
    headers = {"User-Agent": USER_AGENT}
    jwks_client = PyJWKClient(jkws_uri, headers=headers)
    signing_key = jwks_client.get_signing_key_from_jwt(access_token)
    try:
        # Decode and validate the token
        data = jwt.decode(
            jwt=access_token,
            key=signing_key.key,
            algorithms=signing_algos,
            audience=audience,
            issuer=issuers,
        )
    except jwt.ExpiredSignatureError as e:
        logger.error("Token has expired")
        raise e
    except Exception as e:
        logger.error(f"Invalid token or other error: {e}")
        raise e
    # If we get here, the token is valid
    logger.info("Token is valid")
    # Return the decoded token data

    return data


#############################################################################
# end from validate-jwt-token.py
#############################################################################


def callback_uri(
    host: str = "localhost", port: int = 8080, route: str = "/callback"
) -> str:
    """Generate the OAuth callback URI.

    Args:
        host: The hostname for the callback (default: localhost).
        port: The port for the callback (default: 8080).

    Returns:
        The full callback URI.
    """
    return f"http://{host}:{port}{route}"


def get_authorization_code(
    expected_state: str,
    callback_host: str = "localhost",
    callback_port: int = 8080,
    callback_route: str = "/callback",
) -> str:
    """Run temporary HTTP server to receive OAuth callback.

    Convenience wrapper to run the async server in a blocking manner, suitable
    for use in synchronous code.

    Args:
        expected_state: The state parameter to validate.
        callback_host: The hostname for the callback server (default: localhost).
        callback_port: The port for the callback server (default: 8080).
        callback_route: The route for the callback (default: /callback).

    Returns:
        The authorization code from the callback.

    Raises:
        AuthenticationError: If callback handling fails.
    """
    return asyncio.run(
        run_callback_server(
            callback_host=callback_host,
            callback_port=callback_port,
            expected_state=expected_state,
            callback_route=callback_route,
        )
    )


async def run_callback_server(
    expected_state: str,
    callback_host: str = "localhost",
    callback_port: int = 8080,
    callback_route: str = "/callback",
) -> str:
    """Run temporary HTTP server to receive OAuth callback.

    Args:
        expected_state: The state parameter to validate.
        callback_host: The hostname for the callback server (default: localhost).
        callback_port: The port for the callback server (default: 8080).
        callback_route: The route for the callback (default: /callback).

    Returns:
        The authorization code from the callback.

    Raises:
        AuthenticationError: If callback handling fails.
    """
    authorization_code = None
    error_message = None

    async def callback_handler(request: web.Request) -> web.Response:
        nonlocal authorization_code, error_message

        # Check for error in callback
        if "error" in request.query:
            error_message = request.query.get(
                "error_description", request.query["error"]
            )
            return web.Response(
                text="<h1>Authentication Failed</h1>"
                f"<p>Error: {error_message}</p>"
                "<p>You can close this window.</p>",
                content_type="text/html",
            )

        # Validate state parameter
        received_state = request.query.get("state")
        if received_state != expected_state:
            error_message = "Invalid state parameter (possible CSRF attack)"
            return web.Response(
                text="<h1>Authentication Failed</h1>"
                "<p>Security validation failed. Please try again.</p>"
                "<p>You can close this window.</p>",
                content_type="text/html",
            )

        # Get authorization code
        logger.info(f"Received OAuth callback: {request.query!r}")
        authorization_code = request.query.get("code")
        if not authorization_code:
            error_message = "No authorization code received"
            return web.Response(
                text="<h1>Authentication Failed</h1>"
                "<p>No authorization code received.</p>"
                "<p>You can close this window.</p>",
                content_type="text/html",
            )

        return web.Response(
            text="<h1>Authentication Successful</h1>"
            "<p>You can now close this window and return to the application.</p>",
            content_type="text/html",
        )

    # Create and start the server
    app = web.Application()
    app.router.add_get(callback_route, callback_handler)

    runner = web.AppRunner(app)
    await runner.setup()

    site = web.TCPSite(runner, callback_host, callback_port)

    try:
        await site.start()
        logger.info(f"Callback server started on {callback_host}:{callback_port}")

        # Wait for callback or timeout
        timeout = 300  # 5 minutes
        for _ in range(timeout):
            if authorization_code or error_message:
                break
            await asyncio.sleep(1)

        if error_message:
            raise AuthenticationError(f"OAuth callback error: {error_message}")

        if not authorization_code:
            raise AuthenticationError("Timeout waiting for OAuth callback")

        return authorization_code

    finally:
        await runner.cleanup()
        logger.debug("Callback server stopped")


def signing_algos_supported(jkws: JWKS) -> list[str]:
    """Extracts the signing algorithms supported from the JWKS."""
    supported_algos: list[str] = []
    for key in jkws.get("keys", []):
        alg = key.get("alg")
        if alg and alg not in supported_algos:
            supported_algos.append(alg)
    return supported_algos


async def main() -> None:
    """Main function to run the OAuth PKCE flow example."""
    console = Console()
    console.rule("[bold red]EVE SSO Authentication Example Script")
    console.print(
        "[bold]NOTE:[/bold] You must first register an application at [blue]https://developers.eveonline.com/[/blue]"
    )
    console.print()
    console.print(
        "This script demonstrates the OAuth2 Authorization Code Flow with PKCE for the EVE Online ESI."
    )
    console.print(
        "It will provide examples of obtaining an authorization code, exchanging it for tokens, and validating the JWT access token, and refreshing the tokens."
    )
    console.print(
        "Make sure to configure the callback settings in this script to match your EVE SSO application redirect URI."
    )
    console.print()
    ############################################################################
    # auth settings
    ############################################################################

    oauth_metadata_url = (
        "https://login.eveonline.com/.well-known/oauth-authorization-server"
    )
    accepted_issuers = ("logineveonline.com", "https://login.eveonline.com")
    expected_audience = "EVE Online"
    ############################################################################

    ############################################################################
    # Make sure these match your EVE SSO application settings
    ############################################################################

    #  The callback host, port, and route must match the redirect URI configured
    #  in your EVE SSO application.
    callback_host = "localhost"
    callback_port = 8080
    callback_route = "/callback"

    # Define the scopes to request authorization for in the token. Can be a subset
    # of the scopes defined in your EVE SSO application.
    scopes = ["publicData", "esi-characters.read_contacts.v1"]
    ############################################################################

    client_id = console.input("Enter your EVE SSO Client ID: ").strip()
    code_verifier, code_challenge = generate_code_challenge()
    redirect_uri_str = callback_uri(
        host=callback_host, port=callback_port, route=callback_route
    )
    auth_url, state = redirect_to_sso(
        client_id=client_id,
        scopes=scopes,
        redirect_uri=redirect_uri_str,
        challenge=code_challenge,
    )

    console.print("Opening browser for authentication...")
    webbrowser.open(auth_url)
    console.print("Please visit the following URL to authorize the application:")
    console.print(f"[blue]{auth_url}[/blue]")
    console.print(
        f"If the browser does not open automatically, please copy the URL above into your address bar."
    )

    # Wait for the OAuth callback
    try:
        console.print(
            f"Starting http server...\nListening on http://{callback_host}:{callback_port}{callback_route}...\nWaiting for OAuth callback..."
        )
        authorization_code = await run_callback_server(
            expected_state=state,
            callback_host=callback_host,
            callback_port=callback_port,
            callback_route=callback_route,
        )
        console.print("Server stopped.")
        console.print(f"Authorization code received: {authorization_code}")
    except AuthenticationError as e:
        console.print(f"Error during authentication: {e}")
        raise SystemExit(1) from e
    async with aiohttp.ClientSession() as client_session:
        console.print("Requesting access token...")
        esi_token = await request_token(
            client_id=client_id,
            authorization_code=authorization_code,
            code_verifier=code_verifier.decode(),
            client_session=client_session,
        )

        console.print("Access token and refresh token received:")
        console.print(esi_token)

        console.print("Fetching OAuth metadata...")
        auth_metadata = await fetch_oauth_metadata(
            client_session=client_session, oauth_metadata_url=oauth_metadata_url
        )

        console.print("Oauth metadata received:")
        console.print(auth_metadata)

        console.print("Fetching Json Web Key Set (JWKS)...")
        json_web_key_set = await fetch_jwks(
            client_session=client_session, oauth_metadata=auth_metadata
        )
        console.print("Json Web Key Set (JWKS) received:")
        console.print(json_web_key_set)
        # Validate the JWT token
        try:
            signing_algos = signing_algos_supported(json_web_key_set)
            console.print(f"Signing algorithms supported: {signing_algos}")
            jkws_uri = auth_metadata.get("jwks_uri")
            console.print(f"Using {jkws_uri} for the JWKS URI:")
            console.print("Validating JWT token...")
            validated_token = validate_jwt_token(
                esi_token["access_token"],
                jkws_uri=jkws_uri,
                signing_algos=signing_algos,
                audience=expected_audience,
                issuers=accepted_issuers,
            )
            console.print("Validated and decoded JWT Token:")
            console.print(validated_token)
        except Exception as e:
            console.print(f"Error validating JWT token: {e}")
        esi_refresh_token = esi_token.get("refresh_token")
        if esi_refresh_token:
            console.print("Refreshing token...")
            new_token = await refresh_token(
                refresh_token=esi_refresh_token,
                client_id=client_id,
                client_session=client_session,
            )
            console.print("New Access token and refresh token received:")
            console.print(new_token)
        console.print("Esi PKCE auth example completed.")


if __name__ == "__main__":
    asyncio.run(main())
