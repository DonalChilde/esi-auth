# /// script
# requires-python = ">=3.13"
# dependencies = [
#     "aiohttp",
#     "pyjwt[crypto]",
# ]
# ///
import asyncio
import base64
import hashlib
import json
import logging
import random
import secrets
import string
from collections.abc import Sequence
from dataclasses import dataclass
from pathlib import Path
from pprint import pprint
from typing import Any
from urllib.parse import urlencode

import aiohttp
import jwt
from aiohttp import web
from jwt.jwks_client import PyJWKClient

logger = logging.getLogger(__name__)


@dataclass
class Settings:
    client_id: str
    client_secret: str
    redirect_uri: str
    scopes: list[str]
    port: int = 8080
    request_timeout: int = 300  # seconds


class AuthenticationError(Exception):
    """Exception raised during authentication process.

    This exception is raised when authentication fails or encounters
    an error during the OAuth flow or token operations.
    """

    def __init__(self, message: str, error_code: str | None = None):
        """Initialize the authentication error.

        Args:
            message: Human-readable error message.
            error_code: Optional error code for programmatic handling.
        """
        super().__init__(message)
        self.message = message
        self.error_code = error_code


############################################################################
# from authorization-code-pkce.py
############################################################################
def generate_code_challenge() -> tuple[bytes, str]:
    """Generates a code challenge for PKCE.

    :returns: A tuple containing the code verifier and code challenge
    """
    code_verifier = base64.urlsafe_b64encode(secrets.token_bytes(32))
    sha256 = hashlib.sha256()
    sha256.update(code_verifier)
    code_challenge = base64.urlsafe_b64encode(sha256.digest()).decode().rstrip("=")
    return (code_verifier, code_challenge)


async def request_token(
    client_id: str,
    authorization_code: str,
    code_verifier: str,
    client_session: aiohttp.ClientSession | None = None,
) -> dict[str, Any]:
    """Takes an authorization code and code verifier and exchanges it for an access token and refresh token.

    :param str authorization_code: The authorization code received from the SSO
    :param str code_verifier: The code verifier used to generate the code challenge, as generated by `generate_code_challenge`
    :returns: A dictionary containing the access token and refresh token
    """
    if client_session is None:
        client_session = aiohttp.ClientSession()
    headers = {
        "Content-Type": "application/x-www-form-urlencoded",
    }
    payload: dict[str, str] = {
        "grant_type": "authorization_code",
        "code": authorization_code,
        "client_id": client_id,
        "code_verifier": code_verifier,
    }
    async with client_session.post(
        "https://login.eveonline.com/v2/oauth/token", headers=headers, data=payload
    ) as response:
        response.raise_for_status()
        return await response.json()


def redirect_to_sso(
    client_id: str, scopes: Sequence[str], redirect_uri: str, challenge: str
) -> tuple[str, str]:
    """Generates a URL to redirect the user to the SSO for authentication.

    :param list[str] scopes: A list of scopes that the application is requesting access to
    :param str redirect_uri: The URL where the user will be redirected back to after the authorization flow is complete
    :param str challenge: A challenge as generated by `generate_code_challenge`
    :returns: A tuple containing the URL and the state parameter that was used
    """
    state = "".join(random.choices(string.ascii_letters + string.digits, k=16))
    query_params = {
        "response_type": "code",
        "client_id": client_id,
        "redirect_uri": redirect_uri,
        "scope": " ".join(scopes),
        "state": state,
        "code_challenge": challenge,
        "code_challenge_method": "S256",
    }
    query_string = urlencode(query_params)
    return (f"https://login.eveonline.com/v2/oauth/authorize?{query_string}", state)


#############################################################################
# end from authorization-code-pkce.py
#############################################################################

#############################################################################
# from validate-jwt-token.py
#############################################################################
METADATA_URL = "https://login.eveonline.com/.well-known/oauth-authorization-server"
METADATA_CACHE_TIME = 300  # 5 minutes
ACCEPTED_ISSUERS = ("logineveonline.com", "https://login.eveonline.com")
EXPECTED_AUDIENCE = "EVE Online"

client_id = "your_client_id"


async def fetch_auth_metadata(
    client_session: aiohttp.ClientSession | None, metadata_url: str
) -> dict[str, Any]:
    if client_session is None:
        client_session = aiohttp.ClientSession()
    async with client_session.get(metadata_url) as resp:
        resp.raise_for_status()
        return await resp.json()


async def fetch_jwks_metadata(
    client_session: aiohttp.ClientSession | None,
    auth_metadata: Sequence[dict[str, Any]],
) -> dict[str, Any]:
    """Fetches the JWKS metadata from the SSO server.

    :returns: The JWKS metadata
    """
    if client_session is None:
        client_session = aiohttp.ClientSession()
    url: str = auth_metadata.get("jwks_uri")
    logger.info(f"Fetching JWKS metadata from {url}")
    async with client_session.get(url) as resp:
        resp.raise_for_status()
        result = await resp.json()
        file_out = Path().home() / "projects" / "tmp" / "jwks_metadata.json"
        file_out.write_text(json.dumps(result, indent=2))
        return result


def validate_jwt_token(
    access_token: str, jkws_uri: str, signing_algos: list[str]
) -> dict[str, Any]:
    """Validates a JWT Token.

        :param str token: The JWT token to validate
        :returns: The content of the validated JWT access token
        :raises ExpiredSignatureError: If the token has expired
        :raises JWTError: If the token is invalid

        :example:
        {
      "keys": [
        {
          "alg": "RS256",
          "e": "AQAB",
          "kid": "JWT-Signature-Key",
          "kty": "RSA",
          "n": "nehPQ7FQ1YK-leKyIg-aACZaT-DbTL5V1XpXghtLX_bEC-fwxhdE_4yQKDF6cA-V4c-5kh8wMZbfYw5xxgM9DynhMkVrmQFyYB3QMZwydr922UWs3kLz-nO6vi0ldCn-ffM9odUPRHv9UbhM5bB4SZtCrpr9hWQgJ3FjzWO2KosGQ8acLxLtDQfU_lq0OGzoj_oWwUKaN_OVfu80zGTH7mxVeGMJqWXABKd52ByvYZn3wL_hG60DfDWGV_xfLlHMt_WoKZmrXT4V3BCBmbitJ6lda3oNdNeHUh486iqaL43bMR2K4TzrspGMRUYXcudUQ9TycBQBrUlT85NRY9TeOw",
          "use": "sig"
        },
        {
          "alg": "ES256",
          "crv": "P-256",
          "kid": "8878a23f-2489-4045-989e-4d2f3ec1ae1a",
          "kty": "EC",
          "use": "sig",
          "x": "PatzB2HJzZOzmqQyYpQYqn3SAXoVYWrZKmMgJnfK94I",
          "y": "qDb1kUd13fRTN2UNmcgSoQoyqeF_C1MsFlY_a87csnY"
        }
      ],
      "SkipUnresolvedJsonWebKeys": true
    }


    """
    jwks_client = PyJWKClient(jkws_uri)
    signing_key = jwks_client.get_signing_key_from_jwt(access_token)
    data = jwt.decode_complete(
        jwt=access_token,
        key=signing_key,
        algorithms=signing_algos,
        audience=EXPECTED_AUDIENCE,
        issuer=ACCEPTED_ISSUERS,
    )
    pprint(data)
    return data
    # # Fetch the key algorithm and key idfentifier from the token header
    # header = jwt.get_unverified_header(access_token)
    # print(f"Token header: {header}")
    # for key in jwks_metadata["keys"]:
    #     if key["kid"] == header["kid"] and key["alg"] == header["alg"]:
    #         break
    # else:
    #     raise ValueError("No matching key found in JWKS metadata")
    # # key = [
    # #     item
    # #     for item in keys
    # #     if item["kid"] == header["kid"] and item["alg"] == header["alg"]
    # # ].pop()
    # code_key = key
    # return jwt.decode(
    #     access_token,
    #     key=code_key,
    #     algorithms=[
    #         header["alg"],
    #     ],
    #     issuer=ACCEPTED_ISSUERS,
    #     audience=EXPECTED_AUDIENCE,
    # )


def is_token_valid(token):
    """Simple check if the token is valid or not.

    :returns: True if the token is valid, False otherwise
    """
    try:
        claims = validate_jwt_token(token)
        # If our client_id is in the audience list, the token is valid, otherwise, we got a token for another client.
        return client_id in claims["aud"]
    except ExpiredSignatureError:
        # The token has expired
        return False
    except JWTError:
        # The token is invalid
        return False
    except Exception:
        # Something went wrong
        return False


#############################################################################
# end from validate-jwt-token.py
#############################################################################


def callback_uri(
    host: str = "localhost", port: int = 8080, route: str = "/callback"
) -> str:
    """Generate the OAuth callback URI.

    Args:
        host: The hostname for the callback (default: localhost).
        port: The port for the callback (default: 8080).

    Returns:
        The full callback URI.
    """
    return f"http://{host}:{port}{route}"


def get_authorization_code(
    expected_state: str,
    callback_host: str = "localhost",
    callback_port: int = 8080,
    callback_route: str = "/callback",
) -> str:
    """Run temporary HTTP server to receive OAuth callback.

    Args:
        expected_state: The state parameter to validate.

    Returns:
        The authorization code from the callback.

    Raises:
        AuthenticationError: If callback handling fails.
    """
    return asyncio.run(
        run_callback_server(
            callback_host=callback_host,
            callback_port=callback_port,
            expected_state=expected_state,
            callback_route=callback_route,
        )
    )


async def run_callback_server(
    expected_state: str,
    callback_host: str = "localhost",
    callback_port: int = 8080,
    callback_route: str = "/callback",
) -> str:
    """Run temporary HTTP server to receive OAuth callback.

    Args:
        expected_state: The state parameter to validate.

    Returns:
        The authorization code from the callback.

    Raises:
        AuthenticationError: If callback handling fails.
    """
    authorization_code = None
    error_message = None

    async def callback_handler(request: web.Request) -> web.Response:
        nonlocal authorization_code, error_message

        # Check for error in callback
        if "error" in request.query:
            error_message = request.query.get(
                "error_description", request.query["error"]
            )
            return web.Response(
                text="<h1>Authentication Failed</h1>"
                f"<p>Error: {error_message}</p>"
                "<p>You can close this window.</p>",
                content_type="text/html",
            )

        # Validate state parameter
        received_state = request.query.get("state")
        if received_state != expected_state:
            error_message = "Invalid state parameter (possible CSRF attack)"
            return web.Response(
                text="<h1>Authentication Failed</h1>"
                "<p>Security validation failed. Please try again.</p>"
                "<p>You can close this window.</p>",
                content_type="text/html",
            )

        # Get authorization code
        logger.info(f"Received OAuth callback: {request.query!r}")
        authorization_code = request.query.get("code")
        if not authorization_code:
            error_message = "No authorization code received"
            return web.Response(
                text="<h1>Authentication Failed</h1>"
                "<p>No authorization code received.</p>"
                "<p>You can close this window.</p>",
                content_type="text/html",
            )

        return web.Response(
            text="<h1>Authentication Successful</h1>"
            "<p>You can now close this window and return to the application.</p>",
            content_type="text/html",
        )

    # Create and start the server
    app = web.Application()
    app.router.add_get(callback_route, callback_handler)

    runner = web.AppRunner(app)
    await runner.setup()

    site = web.TCPSite(runner, callback_host, callback_port)

    try:
        await site.start()
        logger.info(f"Callback server started on {callback_host}:{callback_port}")

        # Wait for callback or timeout
        timeout = 300  # 5 minutes
        for _ in range(timeout):
            if authorization_code or error_message:
                break
            await asyncio.sleep(1)

        if error_message:
            raise AuthenticationError(f"OAuth callback error: {error_message}")

        if not authorization_code:
            raise AuthenticationError("Timeout waiting for OAuth callback")

        return authorization_code

    finally:
        await runner.cleanup()
        logger.debug("Callback server stopped")


def main() -> None:
    client_id = input("Enter your EVE SSO Client ID: ").strip()
    code_verifier, code_challenge = generate_code_challenge()
    callback_host = "localhost"
    callback_port = 8080
    callback_route = "/callback"
    redirect_uri_str = callback_uri()
    scopes = ["publicData", "esi-characters.read_contacts.v1"]
    auth_url, state = redirect_to_sso(
        client_id=client_id,
        scopes=scopes,
        redirect_uri=redirect_uri_str,
        challenge=code_challenge,
    )
    print("Please visit the following URL to authorize the application:")
    print(auth_url)
    print(
        f"If the browser does not open automatically, please copy the URL above into your address bar."
    )

    # Wait for the OAuth callback
    try:
        authorization_code = get_authorization_code(
            expected_state=state,
            callback_host=callback_host,
            callback_port=callback_port,
            callback_route=callback_route,
        )
        print(f"Authorization code received: {authorization_code}")
    except AuthenticationError as e:
        print(f"Error during authentication: {e}")
        raise SystemExit(1) from e
    token = asyncio.run(
        request_token(
            client_id=client_id,
            authorization_code=authorization_code,
            code_verifier=code_verifier.decode(),
        )
    )
    print("Access token and refresh token received:")
    print(token)
    auth_metadata = asyncio.run(
        fetch_auth_metadata(client_session=None, metadata_url=METADATA_URL)
    )
    print("Auth Metadata:")
    print(auth_metadata)
    jwks_metadata = asyncio.run(
        fetch_jwks_metadata(client_session=None, auth_metadata=auth_metadata)
    )
    print("JWKS Metadata:")
    print(jwks_metadata)
    # Validate the JWT token
    try:
        # siging_algos = auth_metadata.get("id_token_signing_alg_values_supported", [])
        signing_algos = ["RS256", "ES256"]
        print(f"Signing algorithms supported: {signing_algos}")
        jkws_uri = auth_metadata.get("jwks_uri")
        print(f"JWKS URI: {jkws_uri}")
        decoded_token = validate_jwt_token(
            token["access_token"], jkws_uri=jkws_uri, signing_algos=signing_algos
        )
        print("Decoded JWT Token:")
        print(decoded_token)
    except Exception as e:
        print(f"Error validating JWT token: {e}")


if __name__ == "__main__":
    main()
