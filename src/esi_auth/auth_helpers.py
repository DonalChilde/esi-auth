"""Helper functions for OAuth2 authentication with EVE Online SSO."""

############################################################################
# These TypedDicts are used for type hinting the JSON responses from the SSO
# and token endpoints.
############################################################################
import asyncio
import base64
import hashlib
import logging
import random
import secrets
import string
from collections.abc import Sequence
from typing import Any, TypedDict
from urllib.parse import urlencode

import aiohttp
import jwt
from aiohttp import web
from jwt.jwks_client import PyJWKClient

logger = logging.getLogger(__name__)


class JWK(TypedDict):
    """JSON Web Key structure for JWT signature verification."""

    kty: str
    use: str
    kid: str
    alg: str
    n: str
    e: str


class JWKS(TypedDict):
    """JSON Web Key Set containing multiple JWKs."""

    keys: list[JWK]


class VerifiedToken(TypedDict):
    """Represents a verified character token."""

    # TODO confirm these fields
    character_id: int
    character_name: str
    expires_on: str
    scopes: list[str]
    token_type: str
    character_owner_hash: str
    client_id: str
    verified_at: str


class OauthMetadata(TypedDict):
    """OAuth2 server metadata from well-known endpoint."""

    issuer: str
    authorization_endpoint: str
    token_endpoint: str
    revocation_endpoint: str
    jwks_uri: str
    response_types_supported: list[str]
    subject_types_supported: list[str]
    id_token_signing_alg_values_supported: list[str]
    scopes_supported: list[str]
    token_endpoint_auth_methods_supported: list[str]
    claims_supported: list[str]


class OauthToken(TypedDict):
    """OAuth2 token response structure."""

    access_token: str
    token_type: str
    expires_in: int
    refresh_token: str


############################################################################
class AuthenticationError(Exception):
    """Exception raised during authentication process.

    This exception is raised when authentication fails or encounters
    an error during the OAuth flow or token operations.
    """

    def __init__(self, message: str, error_code: str | None = None):
        """Initialize the authentication error.

        Args:
            message: Human-readable error message.
            error_code: Optional error code for programmatic handling.
        """
        super().__init__(message)
        self.message = message
        self.error_code = error_code


def generate_code_challenge() -> tuple[bytes, str]:
    """Generates a code challenge for PKCE.

    Returns:
        A tuple containing the code verifier and code challenge.
    """
    code_verifier = base64.urlsafe_b64encode(secrets.token_bytes(32))
    sha256 = hashlib.sha256()
    sha256.update(code_verifier)
    code_challenge = base64.urlsafe_b64encode(sha256.digest()).decode().rstrip("=")
    return (code_verifier, code_challenge)


async def request_token(
    client_id: str,
    authorization_code: str,
    code_verifier: str,
    token_endpoint: str,
    user_agent: str,
    client_session: aiohttp.ClientSession,
) -> OauthToken:
    """Takes an authorization code and code verifier and exchanges it for an access token and refresh token.

    Args:
        client_id: The client ID of the application.
        authorization_code: The authorization code received from the SSO.
        code_verifier: The code verifier used to generate the code challenge, as generated by `generate_code_challenge`.
        token_endpoint: The token endpoint URI for exchanging the authorization code.
        user_agent: The User-Agent string to use in the request.
        client_session: The aiohttp client session for making requests.

    Returns:
        A dictionary containing the access token and refresh token.

    Raises:
        ValueError: If client_session is not initialized.
        aiohttp.ClientResponseError: If the token request fails.
    """
    if not client_session:
        raise ValueError("client_session must be initialized")
    # if client_session is None:
    #     client_session = aiohttp.ClientSession()
    headers = {
        "Content-Type": "application/x-www-form-urlencoded",
        "User-Agent": user_agent,
    }
    payload: dict[str, str] = {
        "grant_type": "authorization_code",
        "code": authorization_code,
        "client_id": client_id,
        "code_verifier": code_verifier,
    }
    response = await client_session.post(token_endpoint, headers=headers, data=payload)
    response.raise_for_status()
    result = await response.json()

    return result


async def refresh_token(
    refresh_token: str,
    client_id: str,
    token_endpoint: str,
    user_agent: str,
    client_session: aiohttp.ClientSession,
) -> OauthToken:
    """Takes a refresh token and exchanges it for a new access token and refresh token.

    Args:
        refresh_token: The refresh token received from the SSO.
        client_id: The client ID of the application.
        token_endpoint: The token endpoint URI for refreshing tokens.
        user_agent: The User-Agent string to use in the request.
        client_session: The aiohttp client session for making requests.

    Returns:
        A dictionary containing the new access token and refresh token.

    Raises:
        ValueError: If client_session is not initialized.
        aiohttp.ClientResponseError: If the token request fails.
    """
    if not client_session:
        raise ValueError("client_session must be initialized")
    headers = {
        "Content-Type": "application/x-www-form-urlencoded",
        "User-Agent": user_agent,
    }
    payload: dict[str, str] = {
        "client_id": client_id,
        "grant_type": "refresh_token",
        "refresh_token": refresh_token,
    }
    response = await client_session.post(token_endpoint, headers=headers, data=payload)
    response.raise_for_status()
    result = await response.json()

    return result


def redirect_to_sso(
    client_id: str,
    scopes: Sequence[str],
    redirect_uri: str,
    authorization_endpoint: str,
    challenge: str,
) -> tuple[str, str]:
    """Generates a URL to redirect the user to the SSO for authentication.

    Args:
        client_id: The client ID of the application.
        scopes: A list of scopes that the application is requesting access to.
        redirect_uri: The URL where the user will be redirected back to after the authorization flow is complete.
        authorization_endpoint: The authorization endpoint URI.
        challenge: A challenge as generated by `generate_code_challenge`.

    Returns:
        A tuple containing the URL and the state parameter that was used.
    """
    state = "".join(random.choices(string.ascii_letters + string.digits, k=16))
    query_params = {
        "response_type": "code",
        "client_id": client_id,
        "redirect_uri": redirect_uri,
        "scope": " ".join(scopes),
        "state": state,
        "code_challenge": challenge,
        "code_challenge_method": "S256",
    }
    query_string = urlencode(query_params)
    return (f"{authorization_endpoint}?{query_string}", state)


async def fetch_oauth_metadata(
    client_session: aiohttp.ClientSession, oauth_metadata_url: str, user_agent: str
) -> OauthMetadata:
    """Fetches the OAuth metadata from the SSO server.

    Args:
        client_session: The aiohttp client session for making requests.
        oauth_metadata_url: The URL to fetch OAuth metadata from.
        user_agent: The User-Agent string to use in the request.

    Returns:
        The OAuth metadata.

    Raises:
        aiohttp.ClientResponseError: If the metadata request fails.
    """
    header = {"User-Agent": user_agent}
    logger.info(f"Fetching OAuth metadata from {oauth_metadata_url}")
    response = await client_session.get(oauth_metadata_url, headers=header)
    response.raise_for_status()
    result = await response.json()

    return result


async def fetch_jwks(
    client_session: aiohttp.ClientSession,
    user_agent: str,
    jwks_uri: str,
) -> JWKS:
    """Fetches the JWKS metadata from the SSO server.

    Args:
        client_session: The aiohttp client session for making requests.
        user_agent: The User-Agent string to use in the request.
        jwks_uri: The JWKS URI to fetch the keys from.

    Returns:
        The JWKS metadata.

    Raises:
        aiohttp.ClientResponseError: If the JWKS request fails.
    """
    header = {"User-Agent": user_agent}
    logger.info(f"Fetching JWKS from {jwks_uri}")
    response = await client_session.get(jwks_uri, headers=header)
    response.raise_for_status()
    result = await response.json()

    return result


def validate_jwt_token(
    access_token: str,
    jwks_client: PyJWKClient | None,
    audience: str,
    issuers: Sequence[str],
    user_agent: str,
    jwks_uri: str = "",
) -> dict[str, Any]:
    """Validates and decodes a JWT Token.

    Args:
        access_token: The JWT token to validate.
        jwks_uri: The JWKS URI to fetch signing keys from.
        jwks_client: An optional PyJWKClient instance to use for fetching keys.
            If None, a new client will be created.
        audience: Expected audience for the token.
        issuers: Valid issuers for the token.
        user_agent: The User-Agent string to use in requests.

    Returns:
        The content of the validated JWT access token.

    Raises:
        ValueError: If jwks_uri is not provided when jwks_client is None.
        jwt.ExpiredSignatureError: If the token has expired.
        jwt.InvalidTokenError: If the token is invalid.
        Exception: If any other error occurs.
    """
    headers = {"User-Agent": user_agent}
    # NOTE the jwks_client can cache the keys, so we dont have to fetch them every time.
    # Pass in a jwks_client if you have one.
    if jwks_client is None:
        if not jwks_uri:
            raise ValueError("jwks_uri must be provided if jwks_client is None")
        jwks_client = PyJWKClient(jwks_uri, headers=headers)
    unverified_header = jwt.get_unverified_header(access_token)
    kid = unverified_header["kid"]
    alg = unverified_header["alg"]
    signing_key = jwks_client.get_signing_key(kid).key
    try:
        # Decode and validate the token
        data = jwt.decode(
            jwt=access_token,
            key=signing_key,
            algorithms=[alg],
            audience=audience,
            issuer=issuers,
            options={"verify_aud": True, "verify_iss": True},
        )
    except jwt.ExpiredSignatureError as e:
        logger.error("Token has expired")
        raise e
    except Exception as e:
        logger.error(f"Invalid token or other error: {e}")
        raise e
    # If we get here, the token is valid
    logger.info(f"Token is valid. {data=}")
    # Return the decoded token data

    return data


async def revoke_refresh_token(
    access_token: str,
    revocation_endpoint: str,
    client_id: str,
    user_agent: str,
    client_session: aiohttp.ClientSession,
) -> None:
    """Revoke a token.

    Args:
        access_token: The access token to revoke.
        revocation_endpoint: The revocation endpoint URI.
        client_id: The client ID of the application.
        user_agent: The User-Agent string to use in the request.
        client_session: The aiohttp client session for making requests.

    Raises:
        aiohttp.ClientResponseError: If the revocation request fails.
    """
    headers = {
        "Content-Type": "application/x-www-form-urlencoded",
        "User-Agent": user_agent,
    }
    payload: dict[str, str] = {
        "token": access_token,
        "token_type_hint": "refresh_token",
        "client_id": client_id,
    }
    response = await client_session.post(
        revocation_endpoint, headers=headers, data=payload
    )
    response.raise_for_status()
    logger.info("Token revoked successfully")


def callback_uri(
    host: str = "localhost", port: int = 8080, route: str = "/callback"
) -> str:
    """Generate the OAuth callback URI.

    Args:
        host: The hostname for the callback (default: localhost).
        port: The port for the callback (default: 8080).
        route: The route for the callback (default: /callback).

    Returns:
        The full callback URI.
    """
    return f"http://{host}:{port}{route}"


def get_authorization_code(
    expected_state: str,
    callback_host: str = "localhost",
    callback_port: int = 8080,
    callback_route: str = "/callback",
) -> str:
    """Run temporary HTTP server to receive OAuth callback.

    Convenience wrapper to run the async server in a blocking manner, suitable
    for use in synchronous code.

    Args:
        expected_state: The state parameter to validate.
        callback_host: The hostname for the callback server (default: localhost).
        callback_port: The port for the callback server (default: 8080).
        callback_route: The route for the callback (default: /callback).

    Returns:
        The authorization code from the callback.

    Raises:
        AuthenticationError: If callback handling fails.
    """
    return asyncio.run(
        run_callback_server(
            callback_host=callback_host,
            callback_port=callback_port,
            expected_state=expected_state,
            callback_route=callback_route,
        )
    )


async def run_callback_server(
    expected_state: str,
    callback_host: str = "localhost",
    callback_port: int = 8080,
    callback_route: str = "/callback",
) -> str:
    """Run temporary HTTP server to receive OAuth callback.

    Args:
        expected_state: The state parameter to validate.
        callback_host: The hostname for the callback server (default: localhost).
        callback_port: The port for the callback server (default: 8080).
        callback_route: The route for the callback (default: /callback).

    Returns:
        The authorization code from the callback.

    Raises:
        AuthenticationError: If callback handling fails.
    """
    authorization_code = None
    error_message = None

    async def callback_handler(request: web.Request) -> web.Response:
        nonlocal authorization_code, error_message

        # Check for error in callback
        if "error" in request.query:
            error_message = request.query.get(
                "error_description", request.query["error"]
            )
            return web.Response(
                text="<h1>Authentication Failed</h1>"
                f"<p>Error: {error_message}</p>"
                "<p>You can close this window.</p>",
                content_type="text/html",
            )

        # Validate state parameter
        received_state = request.query.get("state")
        if received_state != expected_state:
            error_message = "Invalid state parameter (possible CSRF attack)"
            return web.Response(
                text="<h1>Authentication Failed</h1>"
                "<p>Security validation failed. Please try again.</p>"
                "<p>You can close this window.</p>",
                content_type="text/html",
            )

        # Get authorization code
        logger.info(f"Received OAuth callback: {request.query!r}")
        authorization_code = request.query.get("code")
        if not authorization_code:
            error_message = "No authorization code received"
            return web.Response(
                text="<h1>Authentication Failed</h1>"
                "<p>No authorization code received.</p>"
                "<p>You can close this window.</p>",
                content_type="text/html",
            )

        return web.Response(
            text="<h1>Authentication Successful</h1>"
            "<p>You can now close this window and return to the application.</p>",
            content_type="text/html",
        )

    # Create and start the server
    app = web.Application()
    app.router.add_get(callback_route, callback_handler)

    runner = web.AppRunner(app)
    await runner.setup()

    site = web.TCPSite(runner, callback_host, callback_port)

    try:
        await site.start()
        logger.info(
            f"Callback server started on http://{callback_host}:{callback_port}{callback_route}"
        )

        # Wait for callback or timeout
        timeout = 300  # 5 minutes
        for _ in range(timeout):
            if authorization_code or error_message:
                break
            await asyncio.sleep(1)

        if error_message:
            raise AuthenticationError(f"OAuth callback error: {error_message}")

        if not authorization_code:
            raise AuthenticationError("Timeout waiting for OAuth callback")

        return authorization_code

    finally:
        await runner.cleanup()
        logger.debug("Callback server stopped")


# def signing_algos_supported(jkws: JWKS) -> list[str]:
#     """Extracts the signing algorithms supported from the JWKS.

#     Args:
#         jkws: The JSON Web Key Set containing the signing keys.

#     Returns:
#         A list of supported signing algorithms.
#     """
#     supported_algos: list[str] = []
#     for key in jkws.get("keys", []):
#         alg = key.get("alg")
#         if alg and alg not in supported_algos:
#             supported_algos.append(alg)
#     return supported_algos


# async def make_authenticated_api_call(url: str, access_token: str) -> dict[str, Any]:
#     """Make an authenticated API call using the provided access token.

#     Args:
#         url: The API endpoint URL to call.
#         access_token: The access token for authentication.

#     Returns:
#         The JSON response from the API call.

#     Raises:
#         aiohttp.ClientResponseError: If the API request fails.
#     """
#     headers = {
#         "Authorization": f"Bearer {access_token}",
#         "User-Agent": USER_AGENT,
#     }
#     async with aiohttp.ClientSession() as client_session:
#         response = await client_session.get(url, headers=headers)
#         response.raise_for_status()
#         result = await response.json()
#     return result
